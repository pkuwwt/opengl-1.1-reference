<html>
<head>
<title>OpenGL 1.1 Reference: glDrawPixels</title>
<script language="JavaScript">
<!--
//=== change the button appearance and update the status message =============
function ChangeBtn(Btn, State) {
    var Doc = Btn;
    while ("0123456789".indexOf(Doc.substring(Doc.length - 1)) >= 0)
	Doc = Doc.substring(0, Doc.length - 1);	// truncate last character
    eval("document." + Btn + ".src=\042../buttons/" + Doc +
      (State?"On":"Off") + ".gif\042");
}
// -->
</script>

<meta name="collname" content="unixwork">
<meta name="colltitle" content="unixwork">
<meta name="collsubn" content="unixwork">
<meta name="searchtitle" content="OpenGL 1.1 Reference: glDrawPixels">
</head>
<!-- Version: Version 1.1 -->
<!-- Date:    1 April 1996 -->
<!-- Release: Release 1.1.0 -->
<!-- Dp:      Oct 25 19:24 -->
<!-- Dm:      Oct 25 19:1 -->
<!-- Xs:      14841 30 drawpixels.gl -->

<body background="../images/WhiteMarble.jpg"
      text=000000 link=0000ff alink=ff0000 vlink=aa00aa>
<a name="TOC"></a>
<a href="../OpenGL.html"><img src="images/OpenGL3.gif"
   alt="[Front]" border=0></a>
<a href="../Reference.html" onMouseOver="ChangeBtn('Reference1', 1)"
   onMouseOut="ChangeBtn('Reference1', 0)"><img name="Reference1"
   src="../buttons/ReferenceOff.gif" alt="[Reference]" border=0></a>
<a href="../ImpGuide.html" onMouseOver="ChangeBtn('ImpGuide1', 1)"
   onMouseOut="ChangeBtn('ImpGuide1', 0)"><img name="ImpGuide1"
   src="../buttons/ImpGuideOff.gif" alt="[Imp. Guide]" border=0></a>
<a href="../Index.html" onMouseOver="ChangeBtn('Index1', 1)"
   onMouseOut="ChangeBtn('Index1', 0)"><img name="Index1"
   src="../buttons/IndexOff.gif" alt="[Index]" border=0></a>


<!-- === Name ============================================================= -->
<h1><a name="Name">glDrawPixels</a><br>
<a href="glDrawElements.html" onMouseOver="ChangeBtn('ArrowLeft1', 1)"
   onMouseOut="ChangeBtn('ArrowLeft1', 0)"><img name="ArrowLeft1"
   src="buttons/ArrowLeftOff.gif" alt="[Prev]" border=0></a>
<a href="glEdgeFlag.html" onMouseOver="ChangeBtn('ArrowRight1', 1)"
   onMouseOut="ChangeBtn('ArrowRight1', 0)"><img name="ArrowRight1"
   src="buttons/ArrowRightOff.gif" alt="[Next]" border=0></a></h1>

<tt>glDrawPixels</tt>: write a block of pixels to the frame buffer.
<p>
<center>
<a href="#CSpecification">C Specification</a> |
<a href="#Parameters">Parameters</a> |
<a href="#Description">Description</a> |
<a href="#Errors">Errors</a> |
<a href="#AssociatedGets">Associated Gets</a> |
<a href="#SeeAlso">See Also</a>
</center>


<!-- === C Specification ================================================== -->

<h2><a href="#TOC" onMouseOver="ChangeBtn('ArrowUp1', 1)"
   onMouseOut="ChangeBtn('ArrowUp1', 0)"><img name="ArrowUp1"
   src="buttons/ArrowUpOff.gif" alt="[Up]" border=0></a>
   <a name="CSpecification">C Specification</a></h2>

<pre>
void glDrawPixels(
    GLsizei	 <i>width</i>,
    GLsizei	 <i>height</i>,
    GLenum	 <i>format</i>,
    GLenum	 <i>type</i>,
    const GLvoid <i>*pixels</i>) 
</pre>


<!-- === Parameters ======================================================= -->

<h2><a href="#TOC" onMouseOver="ChangeBtn('ArrowUp2', 1)"
   onMouseOut="ChangeBtn('ArrowUp2', 0)"><img name="ArrowUp2"
   src="buttons/ArrowUpOff.gif" alt="[Up]" border=0></a>
   <a name="Parameters">Parameters</a></h2>

<dl compact>
<dt><tt><i>width</i></tt>, <tt><i>height</i></tt>
<dd>Specify the dimensions of the pixel rectangle to be written into the frame
    buffer.

<dt><tt><i>format</i></tt>
<dd>Specifies the format of the pixel data.  Symbolic constants
    <tt><b>GL_COLOR_INDEX</b></tt>, <tt><b>GL_STENCIL_INDEX</b></tt>,
    <tt><b>GL_DEPTH_COMPONENT</b></tt>, <tt><b>GL_RGBA</b></tt>,
    <tt><b>GL_RED</b></tt>, <tt><b>GL_GREEN</b></tt>, <tt><b>GL_BLUE</b></tt>,
    <tt><b>GL_ALPHA</b></tt>, <tt><b>GL_RGB</b></tt>,
    <tt><b>GL_LUMINANCE</b></tt>, and <tt><b>GL_LUMINANCE_ALPHA</b></tt> are
    accepted.

<dt><tt><i>type</i></tt>
<dd>Specifies the data type for <tt><i>pixels</i></tt>.  Symbolic constants
    <tt><b>GL_UNSIGNED_BYTE</b></tt>, <tt><b>GL_BYTE</b></tt>,
    <tt><b>GL_BITMAP</b></tt>, <tt><b>GL_UNSIGNED_SHORT</b></tt>,
    <tt><b>GL_SHORT</b></tt>, <tt><b>GL_UNSIGNED_INT</b></tt>,
    <tt><b>GL_INT</b></tt>, and <tt><b>GL_FLOAT</b></tt> are accepted.

<dt><tt><i>pixels</i></tt>
<dd>Specifies a pointer to the pixel data.
</dl>


<!-- === Description ====================================================== -->

<h2><a href="#TOC" onMouseOver="ChangeBtn('ArrowUp3', 1)"
   onMouseOut="ChangeBtn('ArrowUp3', 0)"><img name="ArrowUp3"
   src="buttons/ArrowUpOff.gif" alt="[Up]" border=0></a>
   <a name="Description">Description</a></h2>

<tt>glDrawPixels</tt> reads pixel data from memory and writes it into the
frame buffer relative to the current raster position.  Use <a
href="glRasterPos.html"><tt>glRasterPos</tt></a> to set the current raster
position; use <a href="glGet.html"><tt>glGet</tt></a> with argument
<tt><b>GL_CURRENT_RASTER_POSITION</b></tt> to query the raster position.

<p>
Several parameters define the encoding of pixel data in memory and control the
processing of the pixel data before it is placed in the frame buffer.  These
parameters are set with four commands: <a
href="glPixelStore.html"><tt>glPixelStore</tt></a>, <a
href="glPixelTransfer.html"><tt>glPixelTransfer</tt></a>, <a
href="glPixelMap.html"><tt>glPixelMap</tt></a>, and <a
href="glPixelZoom.html"><tt>glPixelZoom</tt></a>.  This reference page
describes the effects on <tt>glDrawPixels</tt> of many, but not all, of the
parameters specified by these four commands.

<p>
Data is read from <tt><i>pixels</i></tt> as a sequence of signed or unsigned
bytes, signed or unsigned shorts, signed or unsigned integers, or
single-precision floating-point values, depending on <tt><i>type</i></tt>.
Each of these bytes, shorts, integers, or floating-point values is interpreted
as one color or depth component, or one index, depending on
<tt><i>format</i></tt>.  Indices are always treated individually.  Color
components are treated as groups of one, two, three, or four values, again
based on <tt><i>format</i></tt>.  Both individual indices and groups of
components are referred to as pixels.  If <tt><i>type</i></tt> is
<tt><b>GL_BITMAP</b></tt>, the data must be unsigned bytes, and
<tt><i>format</i></tt> must be either <tt><b>GL_COLOR_INDEX</b></tt> or
<tt><b>GL_STENCIL_INDEX</b></tt>.  Each unsigned byte is treated as eight
1-bit pixels, with bit ordering determined by
<tt><b>GL_UNPACK_LSB_FIRST</b></tt> (see <a
href="glPixelStore.html"><tt>glPixelStore</tt></a>).

<p>
<nobr><tt><i>width</i></tt><img src="symbols/Times.png"
alt="x"><tt><i>height</i></tt></nobr> pixels are read from memory, starting at
location <tt><i>pixels</i></tt>.  By default, these pixels are taken from
adjacent memory locations, except that after all <tt><i>width</i></tt> pixels
are read, the read pointer is advanced to the next four-byte boundary.  The
four-byte row alignment is specified by <a
href="glPixelStore.html"><tt>glPixelStore</tt></a> with argument
<tt><b>GL_UNPACK_ALIGNMENT</b></tt>, and it can be set to one, two, four, or
eight bytes.  Other pixel store parameters specify different read pointer
advancements, both before the first pixel is read and after all
<tt><i>width</i></tt> pixels are read.  See the <a
href="glPixelStore.html"><tt>glPixelStore</tt></a> reference page for details
on these options.

<p>
The <tt><i>width</i></tt><img src="symbols/Times.png"
alt="x"><tt><i>height</i></tt> pixels that are read from memory are each
operated on in the same way, based on the values of several parameters
specified by <a href="glPixelTransfer.html"><tt>glPixelTransfer</tt></a> and
<a href="glPixelMap.html"><tt>glPixelMap</tt></a>.  The details of these
operations, as well as the target buffer into which the pixels are drawn, are
specific to the format of the pixels, as specified by <tt><i>format</i></tt>.
<tt><i>format</i></tt> can assume one of eleven symbolic values:
    
<dl>
<dt><tt><b>GL_COLOR_INDEX</b></tt>
<dd>Each pixel is a single value, a color index.  It is converted to
    fixed-point format, with an unspecified number of bits to the right of the
    binary point, regardless of the memory data type.  Floating-point values
    convert to true fixed-point values.  Signed and unsigned integer data is
    converted with all fraction bits set to 0.  Bitmap data convert to either
    0 or 1.

    <p>Each fixed-point index is then shifted left by
    <tt><b>GL_INDEX_SHIFT</b></tt> bits and added to
    <tt><b>GL_INDEX_OFFSET</b></tt>.  If <tt><b>GL_INDEX_SHIFT</b></tt> is
    negative, the shift is to the right.  In either case, zero bits fill
    otherwise unspecified bit locations in the result.

    <p>If the GL is in RGBA mode, the resulting index is converted to an RGBA
    pixel with the help of the <tt><b>GL_PIXEL_MAP_I_TO_R</b></tt>,
    <tt><b>GL_PIXEL_MAP_I_TO_G</b></tt>, <tt><b>GL_PIXEL_MAP_I_TO_B</b></tt>,
    and <tt><b>GL_PIXEL_MAP_I_TO_A</b></tt> tables.  If the GL is in color
    index mode, and if <tt><b>GL_MAP_COLOR</b></tt> is true, the index is
    replaced with the value that it references in lookup table
    <tt><b>GL_PIXEL_MAP_I_TO_I</b></tt>.  Whether the lookup replacement of
    the index is done or not, the integer part of the index is then
    <i>and</i>ed with <nobr>2<sup><i>b</i></sup> <img
    src="symbols/Minus.png" alt="-"> 1</nobr>, where <i>b</i> is the number
    of bits in a color index buffer.

    <p>The GL then converts the resulting indices or RGBA colors to fragments
    by attaching the current raster position <tt><i>z</i></tt> coordinate and
    texture coordinates to each pixel, then assigning <i>x</i> and <i>y</i>
    window coordinates to the <i>n</i>th fragment such that
    
    <p align=center>
    <i>x<sub>n</sub></i> = <i>x<sub>r</sub></i> +
                           <i>n</i> mod <tt><i>width</i></tt><br>
    <i>y<sub>n</sub></i> = <i>y<sub>r</sub></i> +
    <img src="symbols/LFloor.png" alt="floor(">
    <i>n</i>/<tt><i>width</i></tt>
    <img src="symbols/RFloor.png" alt=")">
    
    <p>where <nobr>(<i>x<sub>r</sub></i>, <i>y<sub>r</sub></i>)</nobr> is the
    current raster position.  These pixel fragments are then treated just like
    the fragments generated by rasterizing points, lines, or polygons.
    Texture mapping, fog, and all the fragment operations are applied before
    the fragments are written to the frame buffer.

<dt><tt><b>GL_STENCIL_INDEX</b></tt>
<dd>Each pixel is a single value, a stencil index.  It is converted to
    fixed-point format, with an unspecified number of bits to the right of the
    binary point, regardless of the memory data type.  Floating-point values
    convert to true fixed-point values.  Signed and unsigned integer data is
    converted with all fraction bits set to 0.  Bitmap data convert to either
    0 or 1.

    <p>Each fixed-point index is then shifted left by
    <tt><b>GL_INDEX_SHIFT</b></tt> bits, and added to
    <tt><b>GL_INDEX_OFFSET</b></tt>.  If <tt><b>GL_INDEX_SHIFT</b></tt> is
    negative, the shift is to the right.  In either case, zero bits fill
    otherwise unspecified bit locations in the result.  If
    <tt><b>GL_MAP_STENCIL</b></tt> is true, the index is replaced with the
    value that it references in lookup table
    <tt><b>GL_PIXEL_MAP_S_TO_S</b></tt>.  Whether the lookup replacement of
    the index is done or not, the integer part of the index is then
    <i>and</i>ed with <nobr>2<sup><i>b</i></sup> <img
    src="symbols/Minus.png" alt="-"> 1</nobr>, where <i>b</i> is the number
    of bits in the stencil buffer.  The resulting stencil indices are then
    written to the stencil buffer such that the <nobr><i>n</i></nobr>th index
    is written to location

    <p align=center>
    <i>x<sub>n</sub></i> = <i>x<sub>r</sub></i> +
                           <i>n</i> mod <tt><i>width</i></tt><br>
    <i>y<sub>n</sub></i> = <i>y<sub>r</sub></i> +
    <img src="symbols/LFloor.png" alt="floor(">
    <i>n</i>/<tt><i>width</i></tt>
    <img src="symbols/RFloor.png" alt=")">

    <p>where <nobr>(<i>x<sub>r</sub></i>, <i>y<sub>r</sub></i>)</nobr> is the
    current raster position.  Only the pixel ownership test, the scissor test,
    and the stencil writemask affect these write operations.

<dt><tt><b>GL_DEPTH_COMPONENT</b></tt>
<dd>Each pixel is a single-depth component.  Floating-point data is converted
    directly to an internal floating-point format with unspecified precision.
    Signed integer data is mapped linearly to the internal floating-point
    format such that the most positive representable integer value maps to
    1.0, and the most negative representable value maps to <img
    src="symbols/Minus.png" alt="-">1.0.  Unsigned integer data is mapped
    similarly: the largest integer value maps to 1.0, and 0 maps to 0.0.  The
    resulting floating-point depth value is then multiplied by by
    <tt><b>GL_DEPTH_SCALE</b></tt> and added to <tt><b>GL_DEPTH_BIAS</b></tt>.
    The result is clamped to the range <nobr>[0, 1]</nobr>.
    
    <p>The GL then converts the resulting depth components to fragments by
    attaching the current raster position color or color index and texture
    coordinates to each pixel, then assigning <i>x</i> and <i>y</i> window
    coordinates to the <i>n</i>th fragment such that
    
    <p align=center>
    <i>x<sub>n</sub></i> = <i>x<sub>r</sub></i> +
                           <i>n</i> mod <tt><i>width</i></tt><br>
    <i>y<sub>n</sub></i> = <i>y<sub>r</sub></i> +
    <img src="symbols/LFloor.png" alt="floor(">
    <i>n</i>/<tt><i>width</i></tt>
    <img src="symbols/RFloor.png" alt=")">

    <p>where <nobr>(<i>x<sub>r</sub></i>, <i>y<sub>r</sub></i>)</nobr> is the
    current raster position.  These pixel fragments are then treated just like
    the fragments generated by rasterizing points, lines, or polygons.
    Texture mapping, fog, and all the fragment operations are applied before
    the fragments are written to the frame buffer.

<dt><tt><b>GL_RGBA</b></tt>
<dd>Each pixel is a four-component group: for <tt><b>GL_RGBA</b></tt>, the red
    component is first, followed by green, followed by blue, followed by
    alpha.  Floating-point values are converted directly to an internal
    floating-point format with unspecified precision.  Signed integer values
    are mapped linearly to the internal floating-point format such that the
    most positive representable integer value maps to 1.0, and the most
    negative representable value maps to <img src="symbols/Minus.png"
    alt="-">1.0. (Note that this mapping does not convert 0 precisely to 0.0.)
    Unsigned integer data is mapped similarly: the largest integer value maps
    to 1.0, and 0 maps to 0.0.  The resulting floating-point color values are
    then multiplied by <tt><b>GL_</b></tt><i>c</i><tt><b>_SCALE</b></tt> and
    added to <tt><b>GL_</b></tt><i>c</i><tt><b>_BIAS</b></tt>, where <i>c</i>
    is <tt>RED</tt>, <tt>GREEN</tt>, <tt>BLUE</tt>, and <tt>ALPHA</tt> for the
    respective color components.  The results are clamped to the range
    <nobr>[0, 1]</nobr>.
    
    <p>If <tt><b>GL_MAP_COLOR</b></tt> is true, each color component is scaled
    by the size of lookup table
    <tt><b>GL_PIXEL_MAP_</b></tt><i>c</i><tt><b>_TO_</b></tt><i>c</i>, then
    replaced by the value that it references in that table.  <i>c</i> is
    <tt>R</tt>, <tt>G</tt>, <tt>B</tt>, or <tt>A</tt> respectively.
    
    <p>The GL then converts the resulting RGBA colors to fragments by
    attaching the current raster position Z coordinate and texture coordinates
    to each pixel, then assigning <i>x</i> and <i>y</i> window coordinates to
    the <i>n</i>th fragment such that
    
    <p align=center>
    <i>x<sub>n</sub></i> = <i>x<sub>r</sub></i> +
                           <i>n</i> mod <tt><i>width</i></tt><br>
    <i>y<sub>n</sub></i> = <i>y<sub>r</sub></i> +
    <img src="symbols/LFloor.png" alt="floor(">
    <i>n</i>/<tt><i>width</i></tt>
    <img src="symbols/RFloor.png" alt=")">

    <p>where <nobr>(<i>x<sub>r</sub></i>, <i>y<sub>r</sub></i>)</nobr> is the
    current raster position.  These pixel fragments are then treated just like
    the fragments generated by rasterizing points, lines, or polygons.
    Texture mapping, fog, and all the fragment operations are applied before
    the fragments are written to the frame buffer.

<dt><tt><b>GL_RED</b></tt>
<dd>Each pixel is a single red component.  This component is converted to the
    internal floating-point format in the same way the red component of an
    RGBA pixel is. It is then converted to an RGBA pixel with green and blue
    set to 0, and alpha set to 1.  After this conversion, the pixel is treated
    as if it had been read as an RGBA pixel.
    
<dt><tt><b>GL_GREEN</b></tt>
<dd>Each pixel is a single green component.  This component is converted to
    the internal floating-point format in the same way the green component of
    an RGBA pixel is.  It is then converted to an RGBA pixel with red and blue
    set to 0, and alpha set to 1.  After this conversion, the pixel is treated
    as if it had been read as an RGBA pixel.

<dt><tt><b>GL_BLUE</b></tt>
<dd>Each pixel is a single blue component.  This component is converted to the
    internal floating-point format in the same way the blue component of an
    RGBA pixel is.  It is then converted to an RGBA pixel with red and green
    set to 0, and alpha set to 1.  After this conversion, the pixel is treated
    as if it had been read as an RGBA pixel.

<dt><tt><b>GL_ALPHA</b></tt>
<dd>Each pixel is a single alpha component.  This component is converted to
    the internal floating-point format in the same way the alpha component of
    an RGBA pixel is.  It is then converted to an RGBA pixel with red, green,
    and blue set to 0.  After this conversion, the pixel is treated as if it
    had been read as an RGBA pixel.

<dt><tt><b>GL_RGB</b></tt>
<dd>Each pixel is a three-component group: red first, followed by green,
    followed by blue.  Each component is converted to the internal
    floating-point format in the same way the red, green, and blue components
    of an RGBA pixel are.  The color triple is converted to an RGBA pixel with
    alpha set to 1.  After this conversion, the pixel is treated as if it had
    been read as an RGBA pixel.

<dt><tt><b>GL_LUMINANCE</b></tt>
<dd>Each pixel is a single luminance component.  This component is converted
    to the internal floating-point format in the same way the red component of
    an RGBA pixel is.  It is then converted to an RGBA pixel with red, green,
    and blue set to the converted luminance value, and alpha set to 1.  After
    this conversion, the pixel is treated as if it had been read as an RGBA
    pixel.

<dt><tt><b>GL_LUMINANCE_ALPHA</b></tt>
<dd>Each pixel is a two-component group: luminance first, followed by alpha.
    The two components are converted to the internal floating-point format in
    the same way the red component of an RGBA pixel is.  They are then
    converted to an RGBA pixel with red, green, and blue set to the converted
    luminance value, and alpha set to the converted alpha value.  After this
    conversion, the pixel is treated as if it had been read as an RGBA pixel.
</dl>

<p>
The following table summarizes the meaning of the valid constants for the
<tt><i>type</i></tt> parameter:

<p>
<center>
<table border cellspacing=3>
<tr><th><tt>type</tt></th>
    <th>Corresponding Type</th></tr>
<tr><td align=center><tt>GL_UNSIGNED_BYTE</tt></td>
    <td align=center>Unsigned 8-bit integer</td></tr>
<tr><td align=center><tt>GL_BYTE</tt></td>
    <td align=center>Signed 8-bit integer</td></tr>
<tr><td align=center><tt>GL_BITMAP</tt></td>
    <td align=center>Single bits in unsigned 8-bit integers</td></tr>
<tr><td align=center><tt>GL_UNSIGNED_SHORT</tt></td>
    <td align=center>Unsigned 16-bit integer</td></tr>
<tr><td align=center><tt>GL_SHORT</tt></td>
    <td align=center>Signed 16-bit integer</td></tr>
<tr><td align=center><tt>GL_UNSIGNED_INT</tt></td>
    <td align=center>Unsigned 32-bit integer</td></tr>
<tr><td align=center><tt>GL_INT</tt></td>
    <td align=center>32-bit integer</td></tr>
<tr><td align=center><tt>GL_FLOAT</tt></td>
    <td align=center>Single-precision floating-point </td></tr>
</table>
</center>

<p>
The rasterization described so far assumes pixel zoom factors of 1.  If <a
href="glPixelZoom.html"><tt>glPixelZoom</tt></a> is used to change the
<i>x</i> and <i>y</i> pixel zoom factors, pixels are converted to fragments as
follows.  If <nobr>(<i>x<sub>r</sub></i>, <i>y<sub>r</sub></i>)</nobr> is the
current raster position, and a given pixel is in the <i>n</i>th column and
<i>m</i>th row of the pixel rectangle, then fragments are generated for pixels
whose centers are in the rectangle with corners at

<p align=center>
(<i>x<sub>r</sub></i> + <i>zoom<sub>x</sub></i><i>n</i>,
 <i>y<sub>r</sub></i> + <i>zoom<sub>y</sub></i> <i>m</i>)<br> 
(<i>x<sub>r</sub></i> + <i>zoom<sub>x</sub></i> (<i>n</i> + 1),
 <i>y<sub>r</sub></i> + <i>zoom<sub>y</sub></i> (<i>m</i> + 1))

<p>
where <i>zoom<sub>x</sub></i> is the value of <tt><b>GL_ZOOM_X</b></tt> and
<i>zoom<sub>y</sub></i> is the value of <tt><b>GL_ZOOM_Y</b></tt>.


<!-- === Errors =========================================================== -->

<h2><a href="#TOC" onMouseOver="ChangeBtn('ArrowUp4', 1)"
   onMouseOut="ChangeBtn('ArrowUp4', 0)"><img name="ArrowUp4"
   src="buttons/ArrowUpOff.gif" alt="[Up]" border=0></a>
   <a name="Errors">Errors</a></h2>

<ul>
<li><tt><b>GL_INVALID_VALUE</b></tt> is generated if either
    <tt><i>width</i></tt> or <tt><i>height</i></tt> is negative.

<li><tt><b>GL_INVALID_ENUM</b></tt> is generated if <tt><i>format</i></tt> or
    <tt><i>type</i></tt> is not one of the accepted values.

<li><tt><b>GL_INVALID_OPERATION</b></tt> is generated if
    <tt><i>format</i></tt> is <tt><b>GL_RED</b></tt>,
    <tt><b>GL_GREEN</b></tt>, <tt><b>GL_BLUE</b></tt>,
    <tt><b>GL_ALPHA</b></tt>, <tt><b>GL_RGB</b></tt>, <tt><b>GL_RGBA</b></tt>,
    <tt><b>GL_LUMINANCE</b></tt>, or <tt><b>GL_LUMINANCE_ALPHA</b></tt>, and
    the GL is in color index mode.

<li><tt><b>GL_INVALID_ENUM</b></tt> is generated if <tt><i>type</i></tt> is
    <tt><b>GL_BITMAP</b></tt> and <tt><i>format</i></tt> is not either
    <tt><b>GL_COLOR_INDEX</b></tt> or <tt><b>GL_STENCIL_INDEX</b></tt>.
    
<li><tt><b>GL_INVALID_OPERATION</b></tt> is generated if
    <tt><i>format</i></tt> is <tt><b>GL_STENCIL_INDEX</b></tt> and there is no
    stencil buffer.

<li><tt><b>GL_INVALID_OPERATION</b></tt> is generated if <a
    href="glDrawPixels.html"><tt>glDrawPixels</tt></a> is executed between the
    execution of <a href="glBegin.html"><tt>glBegin</tt></a> and the
    corresponding execution of <a href="glBegin.html"><tt>glEnd</tt></a>.
</ul>


<!-- === Associated Gets ================================================== -->

<h2><a href="#TOC" onMouseOver="ChangeBtn('ArrowUp5', 1)"
   onMouseOut="ChangeBtn('ArrowUp5', 0)"><img name="ArrowUp5"
   src="buttons/ArrowUpOff.gif" alt="[Up]" border=0></a>
   <a name="AssociatedGets">Associated Gets</a></h2>

<tt><a href="glGet.html">glGet</a></tt> with argument
<tt><b>GL_CURRENT_RASTER_POSITION</b></tt><br>

<tt><a href="glGet.html">glGet</a></tt> with argument
<tt><b>GL_CURRENT_RASTER_POSITION_VALID</b></tt>


<!-- === See Also ========================================================= -->

<h2><a href="#TOC" onMouseOver="ChangeBtn('ArrowUp6', 1)"
   onMouseOut="ChangeBtn('ArrowUp6', 0)"><img name="ArrowUp6"
   src="buttons/ArrowUpOff.gif" alt="[Up]" border=0></a>
   <a name="SeeAlso">See Also</a></h2>

<tt><a href="glAlphaFunc.html">glAlphaFunc</a></tt>,<br>
<tt><a href="glBlendFunc.html">glBlendFunc</a></tt>,<br>
<tt><a href="glCopyPixels.html">glCopyPixels</a></tt>,<br>
<tt><a href="glDepthFunc.html">glDepthFunc</a></tt>,<br>
<tt><a href="glLogicOp.html">glLogicOp</a></tt>,<br>
<tt><a href="glPixelMap.html">glPixelMap</a></tt>,<br>
<tt><a href="glPixelStore.html">glPixelStore</a></tt>,<br>
<tt><a href="glPixelTransfer.html">glPixelTransfer</a></tt>,<br>
<tt><a href="glPixelZoom.html">glPixelZoom</a></tt>,<br>
<tt><a href="glRasterPos.html">glRasterPos</a></tt>,<br>
<tt><a href="glReadPixels.html">glReadPixels</a></tt>,<br>
<tt><a href="glScissor.html">glScissor</a></tt>,<br>
<tt><a href="glStencilFunc.html">glStencilFunc</a></tt>


<p>
<a href="glDrawElements.html" onMouseOver="ChangeBtn('ArrowLeft2', 1)"
   onMouseOut="ChangeBtn('ArrowLeft2', 0)"><img name="ArrowLeft2"
   src="buttons/ArrowLeftOff.gif" alt="[Prev]" border=0></a>
<a href="glEdgeFlag.html" onMouseOver="ChangeBtn('ArrowRight2', 1)"
   onMouseOut="ChangeBtn('ArrowRight2', 0)"><img name="ArrowRight2"
   src="buttons/ArrowRightOff.gif" alt="[Next]" border=0></a><br>

<a href="../OpenGL.html"><img src="images/OpenGL3.gif"
   alt="Front" border=0></a>
<a href="../Reference.html" onMouseOver="ChangeBtn('Reference2', 1)"
   onMouseOut="ChangeBtn('Reference2', 0)"><img name="Reference2"
   src="../buttons/ReferenceOff.gif" alt="Reference" border=0></a>
<a href="../ImpGuide.html" onMouseOver="ChangeBtn('ImpGuide2', 1)"
   onMouseOut="ChangeBtn('ImpGuide2', 0)"><img name="ImpGuide2"
   src="../buttons/ImpGuideOff.gif" alt="[Imp. Guide]" border=0></a>
<a href="../Index.html" onMouseOver="ChangeBtn('Index2', 1)"
   onMouseOut="ChangeBtn('Index2', 0)"><img name="Index2"
   src="../buttons/IndexOff.gif" alt="Index" border=0></a>
<spacer type=vertical size=500>

</body>
</html>
